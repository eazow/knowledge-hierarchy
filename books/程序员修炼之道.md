#### 注重实效的程序员快速参考指南
The Pragmatic Programmer Quick Reference Guide

1. 关心你的技艺
Care About Your Craft
如果你不在乎能否漂亮地开发出软件，你又为何要耗费生命去开发软件呢？

2. 思考！你的工作
Think！About Your Work
关掉自动驾驶，接管操作，不断地批评和评估你的工作

3. 提供各种选择，不要找蹩脚的借口
Provide Options, Don't Make Lame Excuses
要提供各种选择，而不是找借口，不要说事情做不到，说明能够做什么

4. 不要容忍破窗户
Don't Live with Broken Windows
当你看到糟糕的设计、错误的决策

5. 做变化的催化剂
Be a Catalyst for Change
你不能强迫人们改变。相反，要向他们展示未来可能会怎样，并帮助他们参与对未来的创造

6. 记住大图景
Remember the Big Picture
不要太过专注于细节，已忘了查看周围正在发生什么

7. 使质量成为需求问题
Make Quality a Requirements Issue
让你的用户参与确定项目真正的质量需求

8. 定期为你的知识资产投资
Invest Regularly in Your Knowledge Portfolio
让学习成为习惯

9. 批判地分析你读到和听到的
Critically Analyze What You Read and Hear
不要被供应商、媒体炒作、或教条左右，要依照你自己的看法和你的项目的情况去对信息进行分析

10. 你说什么和你怎样说同样重要
It's Both What You Say and the Way You Say It
如果你不能有效地向他人传达你的了不起的想法，这些想法就毫无用处

11. 不要重复你自己
DRY —— Don't Repeat Yourself
系统中的每一项知识都必须具有单一、无歧义、权威的表示

12. 让复用变得容易

13. 消除无关事物之间的影响

14. 不存在最终决策

15. 用曳光弹找到目标

16. 为了学习而制作原型

17. 靠近问题领域编程

18. 估算，以避免发生意外

19. 通过代码对进度表进行迭代

20. 用纯文本保存知识

21. 利用命令shell的力量

22. 用好一种编辑器

23. 总是使用源码控制

24. 要修正问题，而不是发出指责

25. 调试时不要恐慌

26. "Select"没有问题

27. 不要假定，要证明

28. 学习一种文本操纵语言

29. 编写能编写代码的代码

30. 你不可能写出完美的软件

31. 通过合约进行设计

32. 早崩溃

33. 用断言避免不可能发生的事情

34. 将异常用于异常的问题

35. 要有始有终

36. 使模块之间的耦合减至最少

37. 要配置，不要集成

38. 把抽象放进代码，细节放进元数据

39. 分析工作流，以改善并发性

40. 用服务进行设计

41. 总是为并发进行设计

42. 使视图与模型分离

43. 用黑板协调工作流

44. 不要靠巧合编程

45. 估算你的算法的阶

46. 测试你的估算

47. 早重构，常重构

48. 为测试而设计

49. 测试你的软件，否则你的用户就得测试

50. 不要使用你不理解的向导代码

51. 不要搜集需求——挖掘它们

52. 与用户一同工作，以像用户一样思考

53. 抽象比细节活得更长久

54. 使用项目词汇表

55. 不要在盒子外面思考——要找到盒子

56. 等你准备好再开始

57. 对某些事情“做”胜于“描述”

58. 不要做形式方法的奴隶

59. 昂贵的工具不一定能制作出更好的设计

60. 围绕功能组织团队

61. 不要使用手工流程

62. 早测试，常测试，自动测试

63. 要通过全部测试，编码才算完成

64. 通过“蓄意破坏”测试你的测试

65. 测试状态覆盖，而不是代码覆盖

66. 一个bug只抓一次

67. 英语就是一种编程语言

68. 把文档建在里面，不要拴在外面

69. 温和地超出用户的期望

70. 在你的作品上签名

71. 要学些的语言
每一种语言都有不同的能力和不同的“风味”

72. WISDOM离合诗
你想让他们学到什么？
他们对你讲的什么感兴趣?
他们有多富有经验?
他们想要多少细节?
你想让谁拥有这些信息？
你如何促使他们听你说话？

73. 怎样维持正交性
设计独立、良好定义的组件
使你的代码保持解耦
避免使用全局数据
重构相似的函数

74. 应制作原型的事物
架构
已有系统中的新功能
外部数据的结构或内容
第三方工具或组件
性能问题
用户界面设计

75. 架构问题
责任是否得到了良好定义？
协作是否得到了良好定义？
耦合是否得以最小化？
你能否确定潜在的重复？
接口定义和各项约束是否可接受？
模块能否在需要时访问所需数据？


![](https://upload-images.jianshu.io/upload_images/1425939-569321bf2b021d08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

